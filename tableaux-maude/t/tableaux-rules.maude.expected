==========================================
search in MATCHING-LOGIC-TABLEAUX : tableaux(\and(c, [a (Y{0})])) =>* Sequent:Sequent .

Solution 1 (state 0)
Sequent:Sequent --> < c, [a (Y{0})] ; nil >

No more solutions.
state 0, Sequent: < c, [a (Y{0})] ; nil >
==========================================
search in MATCHING-LOGIC-TABLEAUX : tableaux(\nu Y . \and(c, [a (Y{0})])) =>* Sequent:Sequent .

Solution 1 (state 0)
Sequent:Sequent --> < c, [a (v(0){0})] ; v(0) := \nu * . \and(c, [a (*{0})]) >

No more solutions.
state 0, Sequent: < c, [a (v(0){0})] ; v(0) := \nu * . \and(c, [a (*{0})]) >
==========================================
search in MATCHING-LOGIC-TABLEAUX : tableaux(\nu Y . \and(c, < a (Y{0}) >)) =>* Sequent:Sequent .

Solution 1 (state 0)
Sequent:Sequent --> < c, < a (v(0){0}) > ; v(0) := \nu * . \and(c, < a (*{0}) >) >

No more solutions.
state 0, Sequent: < c, < a (v(0){0}) > ; v(0) := \nu * . \and(c, < a (*{0}) >) >
arc 0 ===> state 0 (crl < Gamma, < Sy P > ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma ; DefList) = true [label all<>] .)
==========================================
search in MATCHING-LOGIC-TABLEAUX : tableaux(\mu Y . \and(c, [a (Y{0})])) =>* Sequent:Sequent .

Solution 1 (state 0)
Sequent:Sequent --> < c, [a (u(0){0})] ; u(0) := \mu * . \and(c, [a (*{0})]) >

No more solutions.
state 0, Sequent: < c, [a (u(0){0})] ; u(0) := \mu * . \and(c, [a (*{0})]) >
==========================================
search in MATCHING-LOGIC-TABLEAUX : tableaux(\mu Y . \and(c, < a (Y{0}) >)) =>* Sequent:Sequent .

Solution 1 (state 0)
Sequent:Sequent --> < c, < a (u(0){0}) > ; u(0) := \mu * . \and(c, < a (*{0}) >) >

No more solutions.
state 0, Sequent: < c, < a (u(0){0}) > ; u(0) := \mu * . \and(c, < a (*{0}) >) >
arc 0 ===> state 0 (crl < Gamma, < Sy P > ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma ; DefList) = true [label all<>] .)
==========================================
search in MATCHING-LOGIC-TABLEAUX : tableaux(\nu Y . \and(c, < a (\mu Y . \and(< a (Y{0}) >, [a (Y{1})])) >)) =>* Sequent:Sequent .

Solution 1 (state 0)
Sequent:Sequent --> < c, < a (\mu * . \and(< a (*{0}) >, [a (v(0){0})])) > ; (v(0) := \nu * . \and(c, < a (\mu * . \and(< a (*{0}) >, [a (*{1})])) >)) (u(1) := \mu * . \and(< a (*{0}) >, [a (v(0){0})])) >

Solution 2 (state 1)
Sequent:Sequent --> < < a (u(1){0}) >, [a (v(0){0})] ; (v(0) := \nu * . \and(c, < a (\mu * . \and(< a (*{0}) >, [a (*{1})])) >)) (u(1) := \mu * . \and(< a (*{0}) >, [a (v(0){0})])) >

Solution 3 (state 2)
Sequent:Sequent --> < c, < a (u(1){0}) >, < a (\mu * . \and(< a (*{0}) >, [a (v(0){0})])) >, [a (v(0){0})] ; (v(0) := \nu * . \and(c, < a (\mu * . \and(< a (*{0}) >, [a (*{1})])) >)) (u(1) := \mu * . \and(< a (*{0}) >, [a (v(0){0})])) >

No more solutions.
Bye.
