symbol list(ArrayIntInt, Int) : Bool
axiom functional(list)

axiom \forall { H { ArrayIntInt }, X { Int } }
      \iff-lfp( list(H { ArrayIntInt }, X { Int })
              , \or( \exists {}
                     \and( \equals(X { Int }, 0)
                         )
                   , \exists {X1 { Int }}
                     \and( list(H { ArrayIntInt }, X1 { Int })
                         , gt(X { Int },0)
                         , \equals(select(H { ArrayIntInt }, X { Int }) , X1 { Int })
                         )
                   )
              )

symbol reachableInNSteps(ArrayIntInt, ArrayIntInt, ArrayIntInt, ArrayIntInt, Int) : Bool
axiom functional(reachableInNSteps)

// addr_X = 1
// addr_Y = 2
// addr_L = 3

axiom \forall { STATE_INIT { ArrayIntInt }, STATE_FINAL { ArrayIntInt }
              , HEAP_INIT { ArrayIntInt }, HEAP_FINAL { ArrayIntInt }
              , N { Int } }
      \iff-lfp( reachableInNSteps( STATE_INIT { ArrayIntInt }
                                 , STATE_FINAL { ArrayIntInt }
                                 , HEAP_INIT { ArrayIntInt }
                                 , HEAP_FINAL { ArrayIntInt }
                                 , N { Int }
                                 )
              , \or( \exists { STATE_NEXT { ArrayIntInt } }
                     \and( gt(select(HEAP_INIT { ArrayIntInt }, select (STATE_INIT { ArrayIntInt }, 3)), 0)
                         , gt(select (STATE_INIT { ArrayIntInt }, 3), 0)
                         , \equals( STATE_NEXT { ArrayIntInt }
                                  , store ( STATE_INIT { ArrayIntInt }
                                          , 3
                                          , select(HEAP_INIT { ArrayIntInt }, select (STATE_INIT { ArrayIntInt }, 3))
                                          )
                                  )
                         , gt(N { Int }, 0)
                         , reachableInNSteps( STATE_NEXT { ArrayIntInt }
                                            , STATE_FINAL { ArrayIntInt }
                                            , HEAP_INIT { ArrayIntInt }
                                            , HEAP_FINAL { ArrayIntInt }
                                            , minus(N { Int }, 1)
                                            )
                         )
                   , \exists { }
                     \and( \equals(STATE_INIT { ArrayIntInt }, STATE_FINAL { ArrayIntInt })
                         , \equals(HEAP_FINAL { ArrayIntInt }
                                 , store ( HEAP_INIT { ArrayIntInt }
                                         , select (STATE_INIT { ArrayIntInt }, 3)
                                         , select (STATE_INIT { ArrayIntInt }, 2)
                                         )
                                )
                         , \equals(select(HEAP_INIT { ArrayIntInt }, select(STATE_INIT { ArrayIntInt }, 2)), 0)
                         , gt(select(STATE_INIT { ArrayIntInt }, 2), 0)
                         , \equals(N { Int }, 0)
                         )
                )
            )

claim \implies ( \and (   list(H_INIT { ArrayIntInt }, select(S_INIT { ArrayIntInt }, 1))
                        , gt(select(S_INIT { ArrayIntInt }, 1), 0)
                        , \equals(select (S_INIT { ArrayIntInt }, 3) , select(S_INIT { ArrayIntInt }, 1))
                        , reachableInNSteps(  S_INIT { ArrayIntInt }
                                            , S_FINAL { ArrayIntInt }
                                            , H_INIT { ArrayIntInt }
                                            , H_FINAL { ArrayIntInt }
                                            , STEPS { Int }
                                        )
                    )
               , \and ( list(H_FINAL { ArrayIntInt }, select(S_FINAL { ArrayIntInt }, 1))
                      )
               )

strategy  normalize . or-split-rhs . lift-constraints . instantiate-existentials . merge-variable-aliases
        . kt-wrap(head: reachableInNSteps)
        . kt-abstract(Rpred)
        . kt-forall-intro . kt-unfold
        . remove-lhs-existential . kt-unwrap 
        . normalize . or-split-rhs . lift-constraints . instantiate-existentials
        . with-each-implication-context( normalize-implication-context
            . kt-abstract-refine )
        . ( ( smt-cvc4 )
          | ( kt-abstract-finalize(Rpred)
            . kt-fold(
                \equals ( select ( H_INIT { ArrayIntInt } , select ( S_INIT { ArrayIntInt } , 2 ) ) , 0 ), 
                \equals ( H_FINAL { ArrayIntInt } , 
                  store ( H_INIT { ArrayIntInt } , select ( S_INIT { ArrayIntInt } , 3 ) , 
                    select ( S_INIT { ArrayIntInt } , 2 ) ) ),
                list ( H_FINAL { ArrayIntInt } , select ( S_INIT { ArrayIntInt } , 3 ) ),
                \equals ( select(H_FINAL { ArrayIntInt } , select ( F52 { ArrayIntInt } , 3)),
                          select(H_INIT { ArrayIntInt } , select ( F52 { ArrayIntInt } , 3)))
            ) 
            . kt-wrap(head: Rpred) . kt-forall-intro . kt-unfold 
            . remove-lhs-existential . kt-unwrap
            . normalize . or-split-rhs . lift-constraints . instantiate-existentials . merge-variable-aliases
            . with-each-implication-context( normalize-implication-context
                . instantiate-context(F58 { Int }, STEPS { Int } )
                . instantiate-context(F59 { ArrayIntInt }, F52 { ArrayIntInt } )
                . instantiate-context(F60 { ArrayIntInt }, H_FINAL { ArrayIntInt } )
                . instantiate-context(F61 { ArrayIntInt }, F52 { ArrayIntInt } )
                . kt-collapse )
            . (   ( kt-solve-implications( right-unfold-Nth(0,1)
                      . instantiate-rhs(F74 { Int }, select ( S_INIT { ArrayIntInt } , 3 ) )
                      . smt-cvc4 )
                  . smt-cvc4 ) 
                | ( wait . noop )
                | ( wait . wait )
            )
          )
          | wait
        )



