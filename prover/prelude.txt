// theory BASIC-LOGIC

notation \not
notation \top
notation \or
notation \and
notation \iff
notation \forall
notation \nu

// The following are notation desugar definitions, implemented as K rules.
// I intend to add them in a separate, companion K module, which will be imported
// by the prover. This is a compromise, to (1) eliminate notations as built-ins, and
// (2) avoid re-implement pattern matching. 
// We also add the following syntax definition to the kore-lang:
//   syntax Pattern ::= desugar(Pattern) [function]
// which denotes one-step notation desugar. We can also define desugar* as the
// "Kleene star" of desugar. 

// rule desugar(\not(P:Pattern)) => \implies(P, \bottom())
// rule desugar(\top()) => \not(\bottom())

// We can let \or and \and take multiple patterns as arguments.
// rule desugar(\or()) => \bottom()
// rule desugar(\or(P:Pattern)) => P
// rule desugar(\or(P:Pattern,Ps:Patterns)) => \implies(\not(P), \or(Ps))
// rule desugar(\and()) => \top()
// rule desugar(\and(P:Pattern)) => P
// rule desugar(\and(P:Pattern,Ps:Patterns) => \not(\not(P), \not(\and(Ps)))

// rule desugar(\iff(P:Pattern,Q:Pattern)) => \and(\implies(P,Q), \implies(Q,P))

// In the following, I use ElementVariable to denote the sort of (unsorted)
// element variables. I also assume that the syntax of \exists and \mu
// has been modified to (which is more uniform):
//   | "\\forall" "(" ElementVariables "," Pattern ")"
//   | "\\mu" "(" SetVariables "," Pattern ")"

// rule desugar(\forall(Xs:ElementVariables, P:Pattern)) => \not(\exists(Xs,\not(P)))
// rule desugar(\nu(SXs:SetVariables, P:Pattern)) => \not(\mu(SXs, P[???]))
// where ??? denotes the substitution of (\neg \SXs)for SXs. 

// endtheory BASIC-LOGIC

// theory DEFINEDNESS
//  imports BASIC-LOGIC

// I want to create a naming convension: symbols are named like: thisIsASymbol
// and notations start with "\".

symbol def
axiom  \forall{X} def(X) // X should be parsed as an element variable.

notation \ceil
notation \floor
notation \eq
notation \subset
notation \in
notation \neq
notation \nsubset
notation \nin

// notation definitions
// rule desugar(\ceil(P:Pattern)) => def(P)
// rule desugar(\floor(P:Pattern)) => \not(\ceil(\not(P)))
// rule desugar(\eq(P:Pattern,Q:Pattern)) => \floor(\iff(P,Q))
// rule desugar(\subset(P:Pattern,Q:Pattern)) => \floor(\implies(P,Q))
// rule desugar(\in(X:ElementVariable, P:Pattern)) => \subset(X,P)
// rule desugar(\neq(P:Pattern,Q:Pattern)) => \not(\eq(P,Q))
// rule desugar(\nsubset(P:Pattern,Q:Pattern)) => \not(\subset(P,Q))
// rule desugar(\nin(X:ElementVariable, P:Pattern)) => \not(\in(X,P))
// endtheory DEFINEDNESS

// The following defines natural numbers. It is part of the prelude, so we
// don't have sorts and functions yet. The "standard" definition of natural
// numbers using the sorts and functions will be defined later, in theory NAT.
// Here, we use unusual names like nn, z, s, because their use should be limited
// to prelude theories.

// theory NN
//  imports DEFINEDNESS

symbol nn   // the set of all natural numbers
symbol pnn  // the set of positive natural numbers
symbol z
symbol s

axiom \exists(X, \and(\in(X, nn), \eq(z, X)))
axiom \forall(X, \implies(\in(X, nn), \exists(Y, \and(\in(Y, nn), \eq(s(X), Y)))))
axiom \neq(s(z), z)
axiom \forall((X,Y), \implies(\and(\in(X,nn), \in(Y,nn)), 
                       \implies(\eq(s(X),s(Y)), \eq(X,Y))))
axiom \eq(nn, \mu(#D, \or(z, s(#D))))
axiom \eq(pnn, s(nn))

// endtheory NN

// theory SORT
//   imports DEFINEDNESS

symbol inh
symbol Sort

notation \snot
notation \sforall
notation \sexists
notation \types

// notation definition
// rule desugar(\snot(SORT:Pattern, P:Pattern)) => \and(\not(P), inh(SORT))
// rule desugar(\sforall(X:ElementVariable, S:Pattern, P:Pattern)) => \forall(X:ElementVariable, \implies(\in(X, inh(S))), P)
// rule desugar(\sforall((X:ElementVariable, Xs:ElementVariables), S:Pattern, P:Pattern)) => \sforall(X, S, \sforall(Xs, S, P))
// rule desugar(\sexists(X:ElementVariable, S:Pattern, P:Pattern)) => \exists(X:ElementVariable, \implies(\in(X, inh(S))), P)
// rule desugar(\sexists((X:ElementVariable, Xs:ElementVariables), S:Pattern, P:Pattern)) => \sexists(X, S, \sexists(Xs, S, P))
// rule desugar(\types(P:Pattern, S:Pattern)) => \sexists(!Z:ElementVariable, S, \eq(P, Z))

// endtheory SORT

// theory PAIR
//   imports SORT

symbol Pair
symbol pair
symbol fst
symbol snd

axiom \sforall((S1,S2), Sort, \types(Pair(S1,S2), Sort))
axiom \sforall((S1,S2), Sort, \sforall(X1, S1, \sforall(X2, S2, \types(pair(X1,X2), Pair(S1,S2)))))
axiom \sforall((S1,S2), Sort, \sforall(X1, S1, \sforall(X2, S2, \eq(fst(pair(X1,X2)), X1))))
axiom \sforall((S1,S2), Sort, \sforall(X1, S1, \sforall(X2, S2, \eq(snd(pair(X1,X2)), X2))))
axiom \sforall((S1,S2), Sort, \sforall((X1,Y1), S1, \sforall((X2,Y2), S2, \implies(\eq(pair(X1,X2), pair(Y1,Y2)), \and(\eq(X1,Y1), \eq(X2,Y2))))))
axiom \sforall((S1,S2), Sort, \eq(inh(Pair(S1,S2)), pair(inh(S1), inh(S2))))

// endtheory PAIR

// theory UNIT

symbol Unit
symbol unit

axiom \types(Unit, Sort)
axiom \types(unit, Unit)
axiom \eq(inh(Unit), unit)
axiom \sforall(S, Sort, \sforall(X, S, \eq(X(unit), X)))

// endtheory UNIT

// theory TUPLE
//   imports PAIR, NN

symbol proj

notation \tuple
notation \Tuple

// notation definition
// desugar(\tuple()) => unit
// desugar(\tuple(P:Pattern)) => P
// desugar(\tuple(P1:Pattern, Ps:Patterns)) => pair(P1, \tuple(Ps))
// desugar(\Tuple()) => Unit
// desugar(\Tuple(S:Pattern)) => S
// desugar(\Tuple(S1:Pattern, Ss:Pattern)) => Pair(S1, \Tuple(Ss))

axiom \sforall((S1,S2), Sort, \sforall(X1, S1, \sforall(X2, S2, \eq(proj(s(z), pair(X1,X2)), X1))))
axiom \sforall((S1,S2), Sort, \sforall(X1, S1, \sforall(X2, S2, \forall(N, \implies(\in(N, pnn), \eq(proj(s(N), pair(X1,X2)), proj(N, X2)))))))

// endtheory TUPLE

// theory FUNCTION
//  imports SORT

symbol Function

axiom \sforall((S1,S2), Sort, \types(Function(S1,S2), Sort))
axiom \sforall((S1,S2), Sort, \eq(inh(Function(S1,S2)), \exists(F, \and(F, \sforall(X, S1, \types(F(X), S2))))))
axiom \sforall((S1,S2), Sort, \sforall((F,G), (Function(S1,S2)), \implies(\sforall(X, S1, \eq(F(X), G(X))), \eq(F,G))))

// endtheory FUNCTION

// theory PRELUDE
//   imports FUNCTION TUPLE
// endtheory PRELUDE


// The following is an example theory for natural numbers, using the infrastructure.

// theory NAT
//   imports PRELUDE

symbol Nat
symbol zero
symbol succ
symbol plus
symbol mult

axiom \types(Nat, Sort)
axiom \types(zero, Function(\Tuple(), Nat))
axiom \types(succ, Function(\Tuple(Nat), Nat))
axiom \types(plus, Function(\Tupel(Nat,Nat), Nat))
axiom \types(mult, Function(\Tuple(Nat,Nat), Nat))

// endtheory NAT