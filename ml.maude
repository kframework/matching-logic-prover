load substitution .

--- Main module for matching logic deductive system.
mod ML is
  including PL-GENERIC-SUBSTITUTION * ( op _,_ to _;_ ) .
  sorts Var Symbol Pattern PatternList .

  subsort Var < Pattern .
  subsort Pattern < PatternList .

  op .PatternList : -> PatternList .
  op _,_ : PatternList PatternList -> PatternList [assoc id: .PatternList prec 37] .

  ops ff gg hh : -> Symbol [ctor] .
  op _() : Symbol -> Pattern [ctor prec 30] .
  op _(_) : Symbol PatternList -> Pattern [ctor prec 30] .

  op E_._ : Var Pattern -> Pattern [ctor prec 31] .
  op A_._ : Var Pattern -> Pattern [ctor prec 31] .
  op ~_ : Pattern -> Pattern [ctor prec 32] .
  op _/\_ : Pattern Pattern -> Pattern [ctor gather (E e) prec 33] .
  op _\/_ : Pattern Pattern -> Pattern [ctor gather (E e) prec 34] .
  op _->_ : Pattern Pattern -> Pattern [ctor gather (e E) prec 35] .
  op _=_ : Pattern Pattern -> Pattern [ctor prec 36] .
  op _=>_ : Pattern Pattern -> Pattern [ctor prec 36] .

  op _[_/_] : Pattern Pattern Var -> Pattern [prec 36].

  var V : Var .  vars P Q : Pattern .

  subsort Id < Var .
  subsort Pattern < GenericTerm .
  eq bind('E_._) = 1 .
  eq bind('A_._) = 1 .
  eq P [Q / V] = substitute (P, Q, V) .
endm


mod ML-DEDUCTIVESYSTEM is
  including ML .
  sort State Command Result .
  sort Proofee .

  op {#_:_} : Int Pattern -> Proofee .
  op _,_ : Proofee Proofee -> Proofee [assoc comm id: done format(n d n d)] .
  op done : -> Proofee .

  op <_>_==========_ : Int Proofee Command -> Result [format(n d d d n n d)] .
  op skip : -> Command .
  op __ : Command Command -> Command [assoc id: skip format(n n d)] .

  op reda_; : Int -> Command .
  op redm_with_; : Int Pattern -> Command . 
  op redu_; : Int -> Command .

  op reda_; : Int -> Command .
  op redm_with_; : Int Pattern -> Command . 
  op redu_; : Int -> Command .

  var P Q R : Pattern .
  var RemP : Proofee .
  var C : Command .
  var N M G : Int .
  var X : Var .

--- Propositional Axioms of the Hilbert Deductive System

rl   < G > { # N : P -> (Q -> P) } , RemP 
     ========== 
     reda N ; C
=> 
     < G > RemP 
     ========== 
     C
.

rl   < G > { # N : (P -> (Q -> R)) -> (( P -> Q ) -> ( P -> R )) } , RemP 
     ========== 
     reda N ; C
=> 
     < G > RemP 
     ========== 
     C 
.

rl   < G > { # N : ( ~ P -> ~ Q ) -> ( Q -> P ) } , RemP 
     ========== 
     reda N ; C
=> 
     < G > RemP 
     ========== 
     C 
.

--- Modus Ponens

rl   < G > { # N : P } , RemP 
     ========== 
     redm N with Q ; C
=>
     < G +Int 2 > { # G : Q } , { # G +Int 1 : Q -> P } , RemP 
     ========== 
     C 
.

--- FOL Axioms

rl   < G > { # N : ((A X . P) -> Q) -> (P -> (A X . Q)) } , RemP 
     ========== 
     reda N ; C
=>
     < G > RemP 
     ========== 
     C 
.

--- Universal Generalization (Elimination)

rl   < G > { # N : (A X . P) } , RemP 
     ==========
     redu N ; C
=>
     < G +Int 1 > { # G : P } , RemP
      ========== 
     C 
. 

--- Functional Substitution

--- rl   < G > { PPPP # N } , RemP ========== reda N ; C
--- =>
---      < G > RemP ========== C .

---Equality Introduction
rl   < G > { # N : P = P } , RemP 
     ========== 
     reda N ; C
=>
     < G > RemP 
     ========== 
     C 
.

endm

rew E 'y . gg ( ff ('x , 'y) => ff( 'y , 'x) , hh () ) [ ff ( 'z , 'y ) / 'x ]
.

quit
