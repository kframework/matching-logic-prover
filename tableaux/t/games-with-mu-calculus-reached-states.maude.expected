==========================================
search in MATCHING-LOGIC-TABLEAUX : tableaux(\and(\mu X . \or([a]X{0}, \nu Y . \and(c, [a]Y{0})), \nu X . \and(< a > X{0}, \mu Y . \or(\not c, < a > Y{0})))) =>* Tableaux .

Solution 1 (state 0)
Tableaux --> < u(0){0}, u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 2 (state 1)
Tableaux --> < u(2){0}, \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 3 (state 2)
Tableaux --> < u(0){0}, u(3){0}, < a > u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 4 (state 3)
Tableaux --> < u(2){0}, [a]u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 5 (state 4)
Tableaux --> < u(1){0}, u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 6 (state 5)
Tableaux --> < u(3){0}, < a > u(2){0}, \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 7 (state 6)
Tableaux --> < u(0){0}, < a > u(2){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 8 (state 7)
Tableaux --> < u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 9 (state 8)
Tableaux --> < u(3){0}, < a > u(2){0}, [a]u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 10 (state 9)
Tableaux --> < c, u(2){0}, [a]u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 11 (state 10)
Tableaux --> < u(1){0}, u(3){0}, < a > u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 12 (state 11)
Tableaux --> < < a > u(2){0}, \or(\not c, < a > u(3){0}), \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 13 (state 12)
Tableaux --> < \not c, u(0){0}, < a > u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 14 (state 13)
Tableaux --> < u(0){0}, < a > u(2){0}, < a > u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 15 (state 14)
Tableaux --> < u(3){0}, < a > u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 16 (state 15)
Tableaux --> < < a > u(2){0}, [a]u(0){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 17 (state 16)
Tableaux --> < c, u(3){0}, < a > u(2){0}, [a]u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 18 (state 17)
Tableaux --> < u(1){0}, < a > u(2){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 19 (state 18)
Tableaux --> < \not c, < a > u(2){0}, \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 20 (state 19)
Tableaux --> < < a > u(2){0}, < a > u(3){0}, \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 21 (state 20)
Tableaux --> < u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 22 (state 21)
Tableaux --> < < a > u(2){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 23 (state 22)
Tableaux --> < \not c, < a > u(2){0}, [a]u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 24 (state 23)
Tableaux --> < < a > u(2){0}, < a > u(3){0}, [a]u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 25 (state 24)
Tableaux --> < c, < a > u(2){0}, [a]u(1){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 26 (state 25)
Tableaux --> < \not c, u(1){0}, < a > u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 27 (state 26)
Tableaux --> < u(1){0}, < a > u(2){0}, < a > u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 28 (state 27)
Tableaux --> < \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 29 (state 28)
Tableaux --> < \not c, < a > u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 30 (state 29)
Tableaux --> < < a > u(2){0}, < a > u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 31 (state 30)
Tableaux --> < u(0){0}, u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 32 (state 31)
Tableaux --> [c, \not c, < a > u(2){0}, [a]u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0}))]

Solution 33 (state 32)
Tableaux --> < c, < a > u(2){0}, < a > u(3){0}, [a]u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 34 (state 33)
Tableaux --> < \not c ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 35 (state 34)
Tableaux --> < < a > u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 36 (state 35)
Tableaux --> < u(3){0}, \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 37 (state 36)
Tableaux --> < u(0){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 38 (state 37)
Tableaux --> < u(1){0}, u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 39 (state 38)
Tableaux --> < u(3){0}, [a]u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 40 (state 39)
Tableaux --> < \or(\not c, < a > u(3){0}), \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 41 (state 40)
Tableaux --> < \not c, u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 42 (state 41)
Tableaux --> < u(0){0}, < a > u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 43 (state 42)
Tableaux --> < u(1){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 44 (state 43)
Tableaux --> < c, u(3){0}, [a]u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 45 (state 44)
Tableaux --> < [a]u(0){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 46 (state 45)
Tableaux --> < \not c, \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 47 (state 46)
Tableaux --> < < a > u(3){0}, \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 48 (state 47)
Tableaux --> < \not c, u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 49 (state 48)
Tableaux --> < u(1){0}, < a > u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 50 (state 49)
Tableaux --> < c, [a]u(1){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 51 (state 50)
Tableaux --> < \not c, [a]u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 52 (state 51)
Tableaux --> < < a > u(3){0}, [a]u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

Solution 53 (state 52)
Tableaux --> [c, \not c, [a]u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0}))]

Solution 54 (state 53)
Tableaux --> < c, < a > u(3){0}, [a]u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

No more solutions.
state 0, Sequent: < u(0){0}, u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 1 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)
arc 1 ===> state 2 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \nu SVar2 . P) DefList2] [label ons-nu] .)

state 1, Sequent: < u(2){0}, \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 3 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 4 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 2 ===> state 5 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \nu SVar2 . P) DefList2] [label ons-nu] .)

state 2, Sequent: < u(0){0}, u(3){0}, < a > u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 5 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)
arc 1 ===> state 6 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)
arc 2 ===> state 7 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)

state 3, Sequent: < u(2){0}, [a]u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 8 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \nu SVar2 . P) DefList2] [label ons-nu] .)

state 4, Sequent: < u(1){0}, u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 9 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \nu SVar2 . P) DefList2] [label ons-nu] .)
arc 1 ===> state 10 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \nu SVar2 . P) DefList2] [label ons-nu] .)

state 5, Sequent: < u(3){0}, < a > u(2){0}, \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 8 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 10 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 2 ===> state 11 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)

state 6, Sequent: < u(0){0}, < a > u(2){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 11 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)
arc 1 ===> state 12 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 2 ===> state 13 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)

state 7, Sequent: < u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 14 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \nu SVar2 . P) DefList2] [label ons-nu] .)

state 8, Sequent: < u(3){0}, < a > u(2){0}, [a]u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 0 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)
arc 1 ===> state 15 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)

state 9, Sequent: < c, u(2){0}, [a]u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 16 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \nu SVar2 . P) DefList2] [label ons-nu] .)

state 10, Sequent: < u(1){0}, u(3){0}, < a > u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 7 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)
arc 1 ===> state 16 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \nu SVar2 . P) DefList2] [label ons-nu] .)
arc 2 ===> state 17 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)

state 11, Sequent: < < a > u(2){0}, \or(\not c, < a > u(3){0}), \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 15 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 17 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 2 ===> state 18 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 3 ===> state 19 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)

state 12, Sequent: < \not c, u(0){0}, < a > u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 7 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)
arc 1 ===> state 18 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)

state 13, Sequent: < u(0){0}, < a > u(2){0}, < a > u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 7 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)
arc 1 ===> state 19 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)
arc 2 ===> state 20 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)

state 14, Sequent: < u(3){0}, < a > u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 7 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)
arc 1 ===> state 21 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)

state 15, Sequent: < < a > u(2){0}, [a]u(0){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 22 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 23 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)

state 16, Sequent: < c, u(3){0}, < a > u(2){0}, [a]u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 4 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)
arc 1 ===> state 24 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)

state 17, Sequent: < u(1){0}, < a > u(2){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 24 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \nu SVar2 . P) DefList2] [label ons-nu] .)
arc 1 ===> state 25 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 2 ===> state 26 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)

state 18, Sequent: < \not c, < a > u(2){0}, \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 22 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 25 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)

state 19, Sequent: < < a > u(2){0}, < a > u(3){0}, \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 23 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 26 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)

state 20, Sequent: < u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 27 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)

state 21, Sequent: < < a > u(2){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 28 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 29 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)

state 22, Sequent: < \not c, < a > u(2){0}, [a]u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 0 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)

state 23, Sequent: < < a > u(2){0}, < a > u(3){0}, [a]u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 0 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)
arc 1 ===> state 30 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)

state 24, Sequent: < c, < a > u(2){0}, [a]u(1){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 31 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 32 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)

state 25, Sequent: < \not c, u(1){0}, < a > u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 7 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)
arc 1 ===> state 31 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \nu SVar2 . P) DefList2] [label ons-nu] .)

state 26, Sequent: < u(1){0}, < a > u(2){0}, < a > u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 7 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)
arc 1 ===> state 20 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)
arc 2 ===> state 32 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \nu SVar2 . P) DefList2] [label ons-nu] .)

state 27, Sequent: < \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 33 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 34 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)

state 28, Sequent: < \not c, < a > u(2){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 7 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)

state 29, Sequent: < < a > u(2){0}, < a > u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 7 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)
arc 1 ===> state 20 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)

state 30, Sequent: < u(0){0}, u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 35 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)
arc 1 ===> state 36 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)

state 31, Sequent: [c, \not c, < a > u(2){0}, [a]u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0}))]

state 32, Sequent: < c, < a > u(2){0}, < a > u(3){0}, [a]u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 4 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)
arc 1 ===> state 37 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)

state 33, Sequent: < \not c ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

state 34, Sequent: < < a > u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 20 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)

state 35, Sequent: < u(3){0}, \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 37 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 38 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 2 ===> state 39 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)

state 36, Sequent: < u(0){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 39 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)
arc 1 ===> state 40 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 2 ===> state 41 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)

state 37, Sequent: < u(1){0}, u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 42 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)
arc 1 ===> state 43 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \nu SVar2 . P) DefList2] [label ons-nu] .)

state 38, Sequent: < u(3){0}, [a]u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 44 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)

state 39, Sequent: < \or(\not c, < a > u(3){0}), \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 42 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 44 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 2 ===> state 45 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 3 ===> state 46 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)

state 40, Sequent: < \not c, u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 45 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)

state 41, Sequent: < u(0){0}, < a > u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 20 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)
arc 1 ===> state 46 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)

state 42, Sequent: < u(1){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 47 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 48 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 2 ===> state 49 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \nu SVar2 . P) DefList2] [label ons-nu] .)

state 43, Sequent: < c, u(3){0}, [a]u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 49 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \mu SVar2 . P) DefList2] [label ons-mu] .)

state 44, Sequent: < [a]u(0){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 50 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 51 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)

state 45, Sequent: < \not c, \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 47 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 50 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)

state 46, Sequent: < < a > u(3){0}, \or([a]u(0){0}, \nu * . \and(c, [a]*{0})) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 48 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 51 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)

state 47, Sequent: < \not c, u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 52 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \nu SVar2 . P) DefList2] [label ons-nu] .)

state 48, Sequent: < u(1){0}, < a > u(3){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 20 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)
arc 1 ===> state 53 (rl < Gamma, SVar1{0} ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 > => [Gamma, [SVar2 := SVar1{0}] P ; DefList1 (SVar1 := \nu SVar2 . P) DefList2] [label ons-nu] .)

state 49, Sequent: < c, [a]u(1){0}, \or(\not c, < a > u(3){0}) ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 52 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)
arc 1 ===> state 53 (crl < Gamma, \or(P1, P2) ; DefList > => [P1, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-l] .) (crl < Gamma, \or(P1, P2) ; DefList > => [P2, Gamma ; DefList] if P1 =/= \bottom = true /\ P2 =/= \bottom = true [label or-r] .)

state 50, Sequent: < \not c, [a]u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >

state 51, Sequent: < < a > u(3){0}, [a]u(0){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 30 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)

state 52, Sequent: [c, \not c, [a]u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0}))]

state 53, Sequent: < c, < a > u(3){0}, [a]u(1){0} ; (u(0) := \mu * . \or([a]*{0}, \nu * . \and(c, [a]*{0}))) (u(1) := \nu * . \and(c, [a]*{0})) (u(2) := \nu * . \and(< a > *{0}, \mu * . \or(\not c, < a > *{0}))) (u(3) := \mu * . \or(\not c, < a > *{0})) >
arc 0 ===> state 37 (crl < Gamma, < Sy > P ; DefList > => [P, getBetas(Sy ; Gamma) ; DefList] if isReduced(Gamma) = true [label all<>] .)
Bye.
