fmod MATCHING-LOGIC-PATTERN is
    protecting NAT .

    sort Pattern .
    sort Symbol .
    sort SetVariable .

    ops a b c : -> Symbol .

    ops X Y Z : -> SetVariable .

    --- We use special constructors for variables for DefinitionConstants
    ops u : Nat -> SetVariable .
    ops v : Nat -> SetVariable .

    subsort Symbol SetVariable < Pattern .
    op \top : -> Pattern .
    op \bottom : -> Pattern .
    op \not _ : Symbol -> Pattern .

    --- We use Modal Mu Calculus application syntax for now.
    op < _ > _ : Symbol Pattern -> Pattern .
    op [ _ ] _ : Symbol Pattern -> Pattern .

    op \and : Pattern Pattern -> Pattern [assoc comm id: \top] .
    op \or  : Pattern Pattern -> Pattern [assoc comm id: \bottom] .

    --- TODO: Plug in CINNI binders?
    op \mu _ . _ : SetVariable Pattern -> Pattern .
    op \nu _ . _ : SetVariable Pattern -> Pattern .

endfm

view Pattern from TRIV to MATCHING-LOGIC-PATTERN is
    sort Elt to Pattern .
endv

view SetVariable from TRIV to MATCHING-LOGIC-PATTERN is
    sort Elt to SetVariable .
endv

fmod MATCHING-LOGIC-PATTERN-SET is
    protecting MATCHING-LOGIC-PATTERN .

    including SET{Pattern}
            * (sort NeSet{Pattern} to NePatternSet, sort Set{Pattern} to PatternSet) .

    sorts SetVariableSet NeSetVariableSet .
    subsorts SetVariable < NeSetVariableSet < SetVariableSet < PatternSet .
    subsorts               NeSetVariableSet < NePatternSet .

    var SVar SVar1 SVar2 : SetVariable .

    op empty : -> SetVariableSet [ctor ditto] .
    op _,_ : SetVariableSet SetVariableSet -> SetVariableSet [ctor ditto] .
    op _,_ : NeSetVariableSet SetVariableSet -> NeSetVariableSet [ctor ditto] .

    --- TODO: We should use TOSET-NEXT based implementation, as in Jose's notes.
    --- For now, we will treat this as an uninterpreted function
    op fresh : SetVariableSet -> SetVariable .
endfm

--- TODO: Should we move this to CINNI?
fmod MATCHING-LOGIC-SUBSTITUTION is
    protecting MATCHING-LOGIC-PATTERN-SET .

    vars SVar SVar1 SVar2 : SetVariable .
    vars P P1 P2 : Pattern .
    vars Sy Sy1 Sy2 : Symbol .

    op fv : Pattern -> SetVariableSet .
   ------------------------------------
    eq fv(SVar) = SVar .
    eq fv(Sy) = empty .
    eq fv(\not Sy) = empty .
    eq fv(< Sy1 > P2) = P2 .
    eq fv([ Sy1 ] P2) = P2 .
   ceq fv(\and(P1, P2)) = fv(P1), fv(P2) if P1 =/= \top    /\ P2 =/= \top    .
   ceq fv(\or (P1, P2)) = fv(P1), fv(P2) if P1 =/= \bottom /\ P2 =/= \bottom .
    eq fv(\mu SVar . P) = fv(P) \ SVar .
    eq fv(\nu SVar . P) = fv(P) \ SVar .

    op [_     := _] _ : SetVariable Pattern Pattern -> Pattern .
   -------------------------------------------------------------
    eq [SVar  := P] Sy    = Sy .
    eq [SVar  := P] \not Sy = \not ([SVar  := P] Sy) .
    eq [SVar  := P] SVar  = P .
   ceq [SVar1 := P] SVar2 = SVar2 if SVar1 =/= SVar2 .
    eq [SVar  := P] < Sy > P1 = < [SVar := P]Sy > [SVar := P]P1 .
    eq [SVar  := P] [ Sy ] P1 = [ [SVar := P]Sy ] [SVar := P]P1 .
   ceq [SVar  := P] \and(P1, P2) = \and([SVar := P]P1, [SVar := P]P2) if P1 =/= \top    /\ P2 =/= \top    .
   ceq [SVar  := P] \or (P1, P2) = \or ([SVar := P]P1, [SVar := P]P2) if P1 =/= \bottom /\ P2 =/= \bottom .

    eq [SVar  := P] \mu SVar  . P1 = \mu SVar  .             P1 .
   ceq [SVar  := P] \mu SVar1 . P1 = \mu SVar1 . [SVar := P] P1                  if SVar1 =/= SVar
                                                                                 /\ not SVar1 in fv(P1) .
   ceq [SVar  := P] \mu SVar1 . P1 = \mu SVar2 . [SVar := P][SVar1 := SVar2 ] P1 if SVar1 =/= SVar
                                                                                 /\ SVar1 in fv(P1)
                                                                                 /\ SVar2 := fresh(union(fv(P), fv(P1))) .

    eq [SVar  := P] \nu SVar  . P1 = \nu SVar  .             P1 .
   ceq [SVar  := P] \nu SVar1 . P1 = \nu SVar1 . [SVar := P] P1                  if SVar1 =/= SVar
                                                                                 /\ not SVar1 in fv(P1) .
   ceq [SVar  := P] \nu SVar1 . P1 = \nu SVar2 . [SVar := P][SVar1 := SVar2 ] P1 if SVar1 =/= SVar
                                                                                 /\ SVar1 in fv(P1)
                                                                                 /\ SVar2 := fresh(union(fv(P), fv(P1))) .
endfm


--- TODO: Can we have DefinitionSet without resorting to a special module?
fmod MATCHING-LOGIC-TABLEAUX-DEFINITION-CONSTANT is
    protecting MATCHING-LOGIC-PATTERN-SET .
    sort DefinitionConstant .
    op ( _ := _ ) : SetVariable Pattern -> DefinitionConstant .
endfm

view DefinitionConstant from TRIV to MATCHING-LOGIC-TABLEAUX-DEFINITION-CONSTANT is
    sort Elt to DefinitionConstant .
endv

fmod MATCHING-LOGIC-TABLEAUX-DEFINITION-LIST is
    protecting MATCHING-LOGIC-TABLEAUX-DEFINITION-CONSTANT .
    protecting MATCHING-LOGIC-PATTERN-SET .
    protecting LIST{DefinitionConstant}
             * ( sort NeList{DefinitionConstant} to NeDefinitionList
               , sort List{DefinitionConstant}   to DefinitionList
               ) .

    vars SVar SVar1 SVar2 : SetVariable .
    vars P P1 P2 : Pattern .
    vars Sy Sy1 Sy2 : Symbol .
    var DefList : DefinitionList .

    op _ in image(_) : Pattern DefinitionList -> Bool .
   ----------------------------------------------------
    eq P in image(nil) = false .
    eq P in image((SVar := P) DefList) = true .
   ceq P1 in image((SVar := P2) DefList) = P1 in image(DefList) if P1 =/= P2 .

    op reverseLookup : Pattern DefinitionList -> [SetVariable] .
   -----------------------------------------------------------
    eq reverseLookup(P, (SVar := P ) DefList) = SVar .
   ceq reverseLookup(P, (SVar := P1) DefList) = reverseLookup(P, DefList) if P =/= P1 .

endfm

fmod MATCHING-LOGIC-TABLEAUX-CONTRACT is
    protecting MATCHING-LOGIC-TABLEAUX-DEFINITION-LIST .
    protecting MATCHING-LOGIC-SUBSTITUTION .

    vars SVar SVar1 SVar2 : SetVariable .
    vars P P1 P2 : Pattern .
    vars Sy Sy1 Sy2 : Symbol .

    op contract : Pattern -> DefinitionList .
   ------------------------------------------
    eq contract(P) = contract(nil, 0, P) .

    var Rank : Nat .
    var DefList : DefinitionList .

    op contract : DefinitionList Nat Pattern -> DefinitionList .
   -------------------------------------------------------------
    eq contract(DefList, Rank, Sy)           = nil .
    eq contract(DefList, Rank, SVar)         = nil .
    eq contract(DefList, Rank, \not Sy)      = nil .
    eq contract(DefList, Rank, < Sy > P)     = contract(DefList, Rank, P) .
    eq contract(DefList, Rank, [ Sy ] P)     = contract(DefList, Rank, P) .
   ceq contract(DefList, Rank, \and(P1, P2)) = merge(contract(DefList, Rank, P1), Rank, P2) if P1 =/= \top    /\ P2 =/= \top .
   ceq contract(DefList, Rank, \or (P1, P2)) = merge(contract(DefList, Rank, P1), Rank, P2) if P1 =/= \bottom /\ P2 =/= \bottom .

   ceq contract(DefList, Rank, \mu SVar . P) = (u(Rank) := \mu SVar . P)
                                               contract(DefList (u(Rank) := \mu SVar . P),  Rank + 1, [SVar := u(Rank)] P)
    if not \mu SVar . P in image(DefList) .
   ceq contract(DefList, Rank, \mu SVar . P) = contract(DefList,  Rank + 1, [SVar := reverseLookup(\mu SVar . P, DefList)] P)
    if \mu SVar . P in image(DefList) .

   ceq contract(DefList, Rank, \nu SVar . P) = (u(Rank) := \nu SVar . P)
                                               contract(DefList (v(Rank) := \nu SVar . P),  Rank + 1, [SVar := v(Rank)] P)
    if not \nu SVar . P in image(DefList) .
   ceq contract(DefList, Rank, \nu SVar . P) = contract(DefList,  Rank + 1, [SVar := reverseLookup(\nu SVar . P, DefList)] P)
    if \nu SVar . P in image(DefList) .

    op merge : DefinitionList Nat Pattern -> DefinitionList .
   ----------------------------------------------------------
    eq merge(DefList, Rank, P) = append(DefList, contract(DefList, Rank + size(DefList), P)) .

endfm

mod MATCHING-LOGIC-TABLEAUX is
    protecting MATCHING-LOGIC-TABLEAUX-CONTRACT .

    sort Tableaux .
    sort Sequent .
    subsorts Sequent < Tableaux .

    var DefList DefList1 DefList2 : DefinitionList .
    var Tableaux : Tableaux .
    vars P P1 P2 : Pattern .
    vars Gamma Ps P1s P2s : PatternSet .
    vars SVar SVar1 SVar2 : SetVariable .
    vars Sy Sy1 Sy2 : Symbol .

    op tableaux : Pattern -> Tableaux .
    -----------------------------------
    eq tableaux(P) = [ P ; contract(P) ] .

    --- Is Inconsistent? ----
    -------------------------

    --- The various tableaux rules apply only if Gamma is consistent.
    --- i.e. if there is no constant c and its negation in Gamma.
    --- We implement this via the special sequent `[_;_]`.
    --- This sequent equals an ordinary sequent only if Gamma is consistent.

    op [_;_] : PatternSet DefinitionList -> Sequent .
   --------------------------------------------------
   ceq [ Gamma ; DefList ] = < Gamma ; DefList >
    if isConsistent(Gamma)
     .

    op isConsistent(_) : PatternSet -> Bool .
    --------------------------------------
    eq isConsistent(empty)               = true .
    eq isConsistent(Sy, \not Sy,  Gamma) = false .
   ceq isConsistent(     Sy,      Gamma) = isConsistent(Gamma) if not (\not Sy) in Gamma .
   ceq isConsistent(\not Sy,      Gamma) = isConsistent(Gamma) if not (     Sy) in Gamma .
    eq isConsistent(\and(P1, P2), Gamma) = isConsistent(Gamma) .
    eq isConsistent(\or (P1, P2), Gamma) = isConsistent(Gamma) .
    eq isConsistent(\mu SVar . P, Gamma) = isConsistent(Gamma) .
    eq isConsistent(\nu SVar . P, Gamma) = isConsistent(Gamma) .
    eq isConsistent(SVar,         Gamma) = isConsistent(Gamma) [owise] .

    ---- Tableaux Rules -----
    -------------------------

    op <_;_> : PatternSet DefinitionList -> Sequent .


   crl [and] : < \and(P1, P2), Gamma ; DefList >
             => ---------------------------------
               [ P1, P2, Gamma ; DefList ]
       if P1 =/= \top /\ P2 =/= \top
     .

   crl [or-l] : < \or(P1, P2), Gamma ; DefList >
             => --------------------------------
                [ P1, Gamma ; DefList ]
       if P1 =/= \bottom /\ P2 =/= \bottom
     .

   crl [or-r] : < \or(P1, P2), Gamma ; DefList >
             => --------------------------------------
                [ P2, Gamma ; DefList ]
       if P1 =/= \bottom /\ P2 =/= \bottom
     .

    rl [ons-mu] : < SVar1, Gamma ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 >
              => -------------------------------------------------------------------------
                 [ [SVar2 := SVar1]P, Gamma ; DefList1 (SVar1 := \mu SVar2 . P) DefList2 ]
               .
    rl [ons-nu] : < SVar1, Gamma ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 >
              => -------------------------------------------------------------------------
                 [ [SVar2 := SVar1]P, Gamma ; DefList1 (SVar1 := \nu SVar2 . P) DefList2 ]
               .

    rl [mu] : < \mu SVar . P, Gamma ; DefList1 (SVar1 := \mu SVar . P) DefList2 >
           => -------------------------------------------------------------------
              [ SVar1, Gamma ; DefList1 (SVar1 := \mu SVar . P) DefList2 ]
       .

    rl [nu] : < \nu SVar . P, Gamma ; DefList1 (SVar1 := \nu SVar . P) DefList2 >
           => -------------------------------------------------------------------
              [ SVar1, Gamma ; DefList1 (SVar1 := \nu SVar . P) DefList2 ]
       .


   crl [all<>] : < < Sy > P , Gamma ; DefList >
              => -------------------------------------
                 [ P, getBetas(Sy ; Gamma) ; DefList ]
       if isReduced(Gamma)
     .

    op isReduced(_) : PatternSet -> Bool .
    eq isReduced(empty) = true .
   ceq isReduced(\and(P1, P2), Gamma) = false if P1 =/= \top /\ P1 =/= \top .
   ceq isReduced(\or (P1, P2), Gamma) = false if P1 =/= \bottom /\ P1 =/= \bottom .
    eq isReduced(\mu SVar1 . P, Gamma) = false .
    eq isReduced(\nu SVar1 . P, Gamma) = false .
    eq isReduced(< Sy > P, Gamma) = isReduced(Gamma) .
    eq isReduced([ Sy ] P, Gamma) = isReduced(Gamma) .
    eq isReduced(Sy, Gamma) = isReduced(Gamma) .
    eq isReduced(SVar, Gamma) = isReduced(Gamma) .
    eq isReduced(\not Sy, Gamma) = isReduced(Gamma) .

    op getBetas(_;_) : Symbol PatternSet -> PatternSet .
    eq getBetas(Sy ; empty ) = empty .
    eq getBetas(Sy ; [ Sy ] P , Gamma ) = P, getBetas(Sy ; Gamma ) .
    eq getBetas(Sy ; P , Gamma ) = getBetas(Sy ; Gamma ) [owise] .

endm
